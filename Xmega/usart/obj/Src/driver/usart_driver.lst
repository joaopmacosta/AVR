   1               		.file	"usart_driver.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 485               	.global	USART_InterruptDriver_Initialize
 487               	USART_InterruptDriver_Initialize:
 488               		.stabd	46,0,0
   1:Src/driver/usart_driver.c **** #include "../../Inc/driver/usart_driver.h"
   2:Src/driver/usart_driver.c **** 
   3:Src/driver/usart_driver.c **** /*! \brief Initializes buffer and selects what USART module to use.
   4:Src/driver/usart_driver.c ****  *
   5:Src/driver/usart_driver.c ****  *  Initializes receive and transmit buffer and selects what USART module to use,
   6:Src/driver/usart_driver.c ****  *  and stores the data register empty interrupt level.
   7:Src/driver/usart_driver.c ****  *
   8:Src/driver/usart_driver.c ****  *  \param usart_data           The USART_data_t struct instance.
   9:Src/driver/usart_driver.c ****  *  \param usart                The USART module.
  10:Src/driver/usart_driver.c ****  *  \param dreIntLevel          Data register empty interrupt level.
  11:Src/driver/usart_driver.c ****  */
  12:Src/driver/usart_driver.c **** void USART_InterruptDriver_Initialize(USART_data_t *usart_data,
  13:Src/driver/usart_driver.c **** 									  USART_t *usart,
  14:Src/driver/usart_driver.c **** 									  USART_DREINTLVL_t dreIntLevel)
  15:Src/driver/usart_driver.c **** {
 490               	.LM0:
 491               	.LFBB1:
 492               	/* prologue: function */
 493               	/* frame size = 0 */
 494               	/* stack size = 0 */
 495               	.L__stack_usage = 0
  16:Src/driver/usart_driver.c **** 	usart_data->usart = usart;
 497               	.LM1:
 498 0000 FC01      		movw r30,r24
 499 0002 6083      		st Z,r22
 500 0004 7183      		std Z+1,r23
  17:Src/driver/usart_driver.c **** 	usart_data->dreIntLevel = dreIntLevel;
 502               	.LM2:
 503 0006 4283      		std Z+2,r20
  18:Src/driver/usart_driver.c **** 
  19:Src/driver/usart_driver.c **** 	usart_data->buffer.RX_Tail = 0;
 505               	.LM3:
 506 0008 EC5F      		subi r30,-4
 507 000a FE4F      		sbci r31,-2
 508 000c 1082      		st Z,__zero_reg__
  20:Src/driver/usart_driver.c **** 	usart_data->buffer.RX_Head = 0;
 510               	.LM4:
 511 000e 3197      		sbiw r30,1
 512 0010 1082      		st Z,__zero_reg__
  21:Src/driver/usart_driver.c **** 	usart_data->buffer.TX_Tail = 0;
 514               	.LM5:
 515 0012 3396      		adiw r30,3
 516 0014 1082      		st Z,__zero_reg__
  22:Src/driver/usart_driver.c **** 	usart_data->buffer.TX_Head = 0;
 518               	.LM6:
 519 0016 3197      		sbiw r30,1
 520 0018 1082      		st Z,__zero_reg__
 521 001a 0895      		ret
 523               	.Lscope1:
 525               		.stabd	78,0,0
 529               	.global	USART_InterruptDriver_DreInterruptLevel_Set
 531               	USART_InterruptDriver_DreInterruptLevel_Set:
 532               		.stabd	46,0,0
  23:Src/driver/usart_driver.c **** }
  24:Src/driver/usart_driver.c **** 
  25:Src/driver/usart_driver.c **** /*! \brief Set USART DRE interrupt level.
  26:Src/driver/usart_driver.c ****  *
  27:Src/driver/usart_driver.c ****  *  Set the interrupt level on Data Register interrupt.
  28:Src/driver/usart_driver.c ****  *
  29:Src/driver/usart_driver.c ****  *  \note Changing the DRE interrupt level in the interrupt driver while it is
  30:Src/driver/usart_driver.c ****  *        running will not change the DRE interrupt level in the USART before the
  31:Src/driver/usart_driver.c ****  *        DRE interrupt have been disabled and enabled again.
  32:Src/driver/usart_driver.c ****  *
  33:Src/driver/usart_driver.c ****  *  \param usart_data         The USART_data_t struct instance
  34:Src/driver/usart_driver.c ****  *  \param dreIntLevel        Interrupt level of the DRE interrupt.
  35:Src/driver/usart_driver.c ****  */
  36:Src/driver/usart_driver.c **** void USART_InterruptDriver_DreInterruptLevel_Set(USART_data_t *usart_data,
  37:Src/driver/usart_driver.c **** 												 USART_DREINTLVL_t dreIntLevel)
  38:Src/driver/usart_driver.c **** {
 534               	.LM7:
 535               	.LFBB2:
 536               	/* prologue: function */
 537               	/* frame size = 0 */
 538               	/* stack size = 0 */
 539               	.L__stack_usage = 0
  39:Src/driver/usart_driver.c **** 	usart_data->dreIntLevel = dreIntLevel;
 541               	.LM8:
 542 001c FC01      		movw r30,r24
 543 001e 6283      		std Z+2,r22
 544 0020 0895      		ret
 546               	.Lscope2:
 548               		.stabd	78,0,0
 551               	.global	USART_TXBuffer_FreeSpace
 553               	USART_TXBuffer_FreeSpace:
 554               		.stabd	46,0,0
  40:Src/driver/usart_driver.c **** }
  41:Src/driver/usart_driver.c **** 
  42:Src/driver/usart_driver.c **** /*! \brief Test if there is data in the transmitter software buffer.
  43:Src/driver/usart_driver.c ****  *
  44:Src/driver/usart_driver.c ****  *  This function can be used to test if there is free space in the transmitter
  45:Src/driver/usart_driver.c ****  *  software buffer.
  46:Src/driver/usart_driver.c ****  *
  47:Src/driver/usart_driver.c ****  *  \param usart_data The USART_data_t struct instance.
  48:Src/driver/usart_driver.c ****  *
  49:Src/driver/usart_driver.c ****  *  \retval true      There is data in the receive buffer.
  50:Src/driver/usart_driver.c ****  *  \retval false     The receive buffer is empty.
  51:Src/driver/usart_driver.c ****  */
  52:Src/driver/usart_driver.c **** bool USART_TXBuffer_FreeSpace(USART_data_t *usart_data)
  53:Src/driver/usart_driver.c **** {
 556               	.LM9:
 557               	.LFBB3:
 558               	/* prologue: function */
 559               	/* frame size = 0 */
 560               	/* stack size = 0 */
 561               	.L__stack_usage = 0
  54:Src/driver/usart_driver.c **** 	/* Make copies to make sure that volatile access is specified. */
  55:Src/driver/usart_driver.c **** 	uint8_t tempHead = (usart_data->buffer.TX_Head + 1) & USART_TX_BUFFER_MASK;
 563               	.LM10:
 564 0022 FC01      		movw r30,r24
 565 0024 EB5F      		subi r30,-5
 566 0026 FE4F      		sbci r31,-2
 567 0028 9081      		ld r25,Z
  56:Src/driver/usart_driver.c **** 	uint8_t tempTail = usart_data->buffer.TX_Tail;
 569               	.LM11:
 570 002a 3196      		adiw r30,1
 571 002c 2081      		ld r18,Z
  57:Src/driver/usart_driver.c **** 
  58:Src/driver/usart_driver.c **** 	/* There are data left in the buffer unless Head and Tail are equal. */
  59:Src/driver/usart_driver.c **** 	return (tempHead != tempTail);
 573               	.LM12:
 574 002e 9F5F      		subi r25,lo8(-(1))
 575 0030 9F77      		andi r25,lo8(127)
 576 0032 81E0      		ldi r24,lo8(1)
 577 0034 9213      		cpse r25,r18
 578 0036 00C0      		rjmp .L4
 579 0038 80E0      		ldi r24,0
 580               	.L4:
  60:Src/driver/usart_driver.c **** }
 582               	.LM13:
 583 003a 0895      		ret
 588               	.Lscope3:
 590               		.stabd	78,0,0
 594               	.global	USART_TXBuffer_PutByte
 596               	USART_TXBuffer_PutByte:
 597               		.stabd	46,0,0
  61:Src/driver/usart_driver.c **** 
  62:Src/driver/usart_driver.c **** /*! \brief Put data (5-8 bit character).
  63:Src/driver/usart_driver.c ****  *
  64:Src/driver/usart_driver.c ****  *  Stores data byte in TX software buffer and enables DRE interrupt if there
  65:Src/driver/usart_driver.c ****  *  is free space in the TX software buffer.
  66:Src/driver/usart_driver.c ****  *
  67:Src/driver/usart_driver.c ****  *  \param usart_data The USART_data_t struct instance.
  68:Src/driver/usart_driver.c ****  *  \param data       The data to send.
  69:Src/driver/usart_driver.c ****  */
  70:Src/driver/usart_driver.c **** bool USART_TXBuffer_PutByte(USART_data_t *usart_data, uint8_t data)
  71:Src/driver/usart_driver.c **** {
 599               	.LM14:
 600               	.LFBB4:
 601 003c 1F93      		push r17
 602 003e CF93      		push r28
 603 0040 DF93      		push r29
 604               	/* prologue: function */
 605               	/* frame size = 0 */
 606               	/* stack size = 3 */
 607               	.L__stack_usage = 3
 608 0042 EC01      		movw r28,r24
 609 0044 162F      		mov r17,r22
  72:Src/driver/usart_driver.c **** 	uint8_t tempCTRLA;
  73:Src/driver/usart_driver.c **** 	uint8_t tempTX_Head;
  74:Src/driver/usart_driver.c **** 	bool TXBuffer_FreeSpace;
  75:Src/driver/usart_driver.c **** 	USART_Buffer_t *TXbufPtr;
  76:Src/driver/usart_driver.c **** 
  77:Src/driver/usart_driver.c **** 	TXbufPtr = &usart_data->buffer;
  78:Src/driver/usart_driver.c **** 	TXBuffer_FreeSpace = USART_TXBuffer_FreeSpace(usart_data);
 611               	.LM15:
 612 0046 0E94 0000 		call USART_TXBuffer_FreeSpace
  79:Src/driver/usart_driver.c **** 
  80:Src/driver/usart_driver.c **** 	if (TXBuffer_FreeSpace)
 614               	.LM16:
 615 004a 8823      		tst r24
 616 004c 01F0      		breq .L7
  81:Src/driver/usart_driver.c **** 	{
  82:Src/driver/usart_driver.c **** 		tempTX_Head = TXbufPtr->TX_Head;
 618               	.LM17:
 619 004e DE01      		movw r26,r28
 620 0050 AB5F      		subi r26,-5
 621 0052 BE4F      		sbci r27,-2
 622 0054 9C91      		ld r25,X
  83:Src/driver/usart_driver.c **** 		TXbufPtr->TX[tempTX_Head] = data;
 624               	.LM18:
 625 0056 FE01      		movw r30,r28
 626 0058 E90F      		add r30,r25
 627 005a F11D      		adc r31,__zero_reg__
 628 005c ED57      		subi r30,125
 629 005e FF4F      		sbci r31,-1
 630 0060 1083      		st Z,r17
  84:Src/driver/usart_driver.c **** 		/* Advance buffer head. */
  85:Src/driver/usart_driver.c **** 		TXbufPtr->TX_Head = (tempTX_Head + 1) & USART_TX_BUFFER_MASK;
 632               	.LM19:
 633 0062 9F5F      		subi r25,lo8(-(1))
 634 0064 9F77      		andi r25,lo8(127)
 635 0066 9C93      		st X,r25
  86:Src/driver/usart_driver.c **** 
  87:Src/driver/usart_driver.c **** 		/* Enable DRE interrupt. */
  88:Src/driver/usart_driver.c **** 		tempCTRLA = usart_data->usart->CTRLA;
 637               	.LM20:
 638 0068 E881      		ld r30,Y
 639 006a F981      		ldd r31,Y+1
 640 006c 9381      		ldd r25,Z+3
  89:Src/driver/usart_driver.c **** 		tempCTRLA = (tempCTRLA & ~USART_DREINTLVL_gm) | usart_data->dreIntLevel;
 642               	.LM21:
 643 006e 9C7F      		andi r25,lo8(-4)
 644 0070 2A81      		ldd r18,Y+2
 645 0072 922B      		or r25,r18
  90:Src/driver/usart_driver.c **** 		usart_data->usart->CTRLA = tempCTRLA;
 647               	.LM22:
 648 0074 9383      		std Z+3,r25
 649               	.L7:
 650               	/* epilogue start */
  91:Src/driver/usart_driver.c **** 	}
  92:Src/driver/usart_driver.c **** 	return TXBuffer_FreeSpace;
  93:Src/driver/usart_driver.c **** }
 652               	.LM23:
 653 0076 DF91      		pop r29
 654 0078 CF91      		pop r28
 655 007a 1F91      		pop r17
 656 007c 0895      		ret
 662               	.Lscope4:
 664               		.stabd	78,0,0
 667               	.global	USART_RXBufferData_Available
 669               	USART_RXBufferData_Available:
 670               		.stabd	46,0,0
  94:Src/driver/usart_driver.c **** 
  95:Src/driver/usart_driver.c **** /*! \brief Test if there is data in the receive software buffer.
  96:Src/driver/usart_driver.c ****  *
  97:Src/driver/usart_driver.c ****  *  This function can be used to test if there is data in the receive software
  98:Src/driver/usart_driver.c ****  *  buffer.
  99:Src/driver/usart_driver.c ****  *
 100:Src/driver/usart_driver.c ****  *  \param usart_data         The USART_data_t struct instance
 101:Src/driver/usart_driver.c ****  *
 102:Src/driver/usart_driver.c ****  *  \retval true      There is data in the receive buffer.
 103:Src/driver/usart_driver.c ****  *  \retval false     The receive buffer is empty.
 104:Src/driver/usart_driver.c ****  */
 105:Src/driver/usart_driver.c **** bool USART_RXBufferData_Available(USART_data_t *usart_data)
 106:Src/driver/usart_driver.c **** {
 672               	.LM24:
 673               	.LFBB5:
 674               	/* prologue: function */
 675               	/* frame size = 0 */
 676               	/* stack size = 0 */
 677               	.L__stack_usage = 0
 107:Src/driver/usart_driver.c **** 	/* Make copies to make sure that volatile access is specified. */
 108:Src/driver/usart_driver.c **** 	uint8_t tempHead = usart_data->buffer.RX_Head;
 679               	.LM25:
 680 007e FC01      		movw r30,r24
 681 0080 ED5F      		subi r30,-3
 682 0082 FE4F      		sbci r31,-2
 683 0084 2081      		ld r18,Z
 109:Src/driver/usart_driver.c **** 	uint8_t tempTail = usart_data->buffer.RX_Tail;
 685               	.LM26:
 686 0086 3196      		adiw r30,1
 687 0088 9081      		ld r25,Z
 110:Src/driver/usart_driver.c **** 
 111:Src/driver/usart_driver.c **** 	/* There are data left in the buffer unless Head and Tail are equal. */
 112:Src/driver/usart_driver.c **** 	return (tempHead != tempTail);
 689               	.LM27:
 690 008a 81E0      		ldi r24,lo8(1)
 691 008c 2913      		cpse r18,r25
 692 008e 00C0      		rjmp .L12
 693 0090 80E0      		ldi r24,0
 694               	.L12:
 113:Src/driver/usart_driver.c **** }
 696               	.LM28:
 697 0092 0895      		ret
 703               	.Lscope5:
 705               		.stabd	78,0,0
 708               	.global	USART_RXBuffer_GetByte
 710               	USART_RXBuffer_GetByte:
 711               		.stabd	46,0,0
 114:Src/driver/usart_driver.c **** 
 115:Src/driver/usart_driver.c **** /*! \brief Get received data (5-8 bit character).
 116:Src/driver/usart_driver.c ****  *
 117:Src/driver/usart_driver.c ****  *  The function USART_RXBufferData_Available should be used before this
 118:Src/driver/usart_driver.c ****  *  function is used to ensure that data is available.
 119:Src/driver/usart_driver.c ****  *
 120:Src/driver/usart_driver.c ****  *  Returns data from RX software buffer.
 121:Src/driver/usart_driver.c ****  *
 122:Src/driver/usart_driver.c ****  *  \param usart_data       The USART_data_t struct instance.
 123:Src/driver/usart_driver.c ****  *
 124:Src/driver/usart_driver.c ****  *  \return         Received data.
 125:Src/driver/usart_driver.c ****  */
 126:Src/driver/usart_driver.c **** uint8_t USART_RXBuffer_GetByte(USART_data_t *usart_data)
 127:Src/driver/usart_driver.c **** {
 713               	.LM29:
 714               	.LFBB6:
 715               	/* prologue: function */
 716               	/* frame size = 0 */
 717               	/* stack size = 0 */
 718               	.L__stack_usage = 0
 128:Src/driver/usart_driver.c **** 	USART_Buffer_t *bufPtr;
 129:Src/driver/usart_driver.c **** 	uint8_t ans;
 130:Src/driver/usart_driver.c **** 
 131:Src/driver/usart_driver.c **** 	bufPtr = &usart_data->buffer;
 132:Src/driver/usart_driver.c **** 	ans = (bufPtr->RX[bufPtr->RX_Tail]);
 720               	.LM30:
 721 0094 FC01      		movw r30,r24
 722 0096 EC5F      		subi r30,-4
 723 0098 FE4F      		sbci r31,-2
 724 009a 2081      		ld r18,Z
 725 009c DC01      		movw r26,r24
 726 009e A20F      		add r26,r18
 727 00a0 B11D      		adc r27,__zero_reg__
 728 00a2 1396      		adiw r26,3
 729 00a4 8C91      		ld r24,X
 133:Src/driver/usart_driver.c **** 
 134:Src/driver/usart_driver.c **** 	/* Advance buffer tail. */
 135:Src/driver/usart_driver.c **** 	bufPtr->RX_Tail = (bufPtr->RX_Tail + 1) & USART_RX_BUFFER_MASK;
 731               	.LM31:
 732 00a6 9081      		ld r25,Z
 733 00a8 9F5F      		subi r25,lo8(-(1))
 734 00aa 9F77      		andi r25,lo8(127)
 735 00ac 9083      		st Z,r25
 136:Src/driver/usart_driver.c **** 
 137:Src/driver/usart_driver.c **** 	return ans;
 138:Src/driver/usart_driver.c **** }
 737               	.LM32:
 738 00ae 0895      		ret
 743               	.Lscope6:
 745               		.stabd	78,0,0
 748               	.global	USART_RXComplete
 750               	USART_RXComplete:
 751               		.stabd	46,0,0
 139:Src/driver/usart_driver.c **** 
 140:Src/driver/usart_driver.c **** /*! \brief RX Complete Interrupt Service Routine.
 141:Src/driver/usart_driver.c ****  *
 142:Src/driver/usart_driver.c ****  *  RX Complete Interrupt Service Routine.
 143:Src/driver/usart_driver.c ****  *  Stores received data in RX software buffer.
 144:Src/driver/usart_driver.c ****  *
 145:Src/driver/usart_driver.c ****  *  \param usart_data      The USART_data_t struct instance.
 146:Src/driver/usart_driver.c ****  */
 147:Src/driver/usart_driver.c **** bool USART_RXComplete(USART_data_t *usart_data)
 148:Src/driver/usart_driver.c **** {
 753               	.LM33:
 754               	.LFBB7:
 755 00b0 CF93      		push r28
 756 00b2 DF93      		push r29
 757               	/* prologue: function */
 758               	/* frame size = 0 */
 759               	/* stack size = 2 */
 760               	.L__stack_usage = 2
 761 00b4 FC01      		movw r30,r24
 149:Src/driver/usart_driver.c **** 	USART_Buffer_t *bufPtr;
 150:Src/driver/usart_driver.c **** 	bool ans;
 151:Src/driver/usart_driver.c **** 
 152:Src/driver/usart_driver.c **** 	bufPtr = &usart_data->buffer;
 153:Src/driver/usart_driver.c **** 	/* Advance buffer head. */
 154:Src/driver/usart_driver.c **** 	uint8_t tempRX_Head = (bufPtr->RX_Head + 1) & USART_RX_BUFFER_MASK;
 763               	.LM34:
 764 00b6 DC01      		movw r26,r24
 765 00b8 AD5F      		subi r26,-3
 766 00ba BE4F      		sbci r27,-2
 767 00bc 9C91      		ld r25,X
 768 00be 9F5F      		subi r25,lo8(-(1))
 769 00c0 9F77      		andi r25,lo8(127)
 155:Src/driver/usart_driver.c **** 
 156:Src/driver/usart_driver.c **** 	/* Check for overflow. */
 157:Src/driver/usart_driver.c **** 	uint8_t tempRX_Tail = bufPtr->RX_Tail;
 771               	.LM35:
 772 00c2 EF01      		movw r28,r30
 773 00c4 CC5F      		subi r28,-4
 774 00c6 DE4F      		sbci r29,-2
 775 00c8 2881      		ld r18,Y
 158:Src/driver/usart_driver.c **** 	uint8_t data = usart_data->usart->DATA;
 777               	.LM36:
 778 00ca C081      		ld r28,Z
 779 00cc D181      		ldd r29,Z+1
 780 00ce 8881      		ld r24,Y
 159:Src/driver/usart_driver.c **** 
 160:Src/driver/usart_driver.c **** 	if (tempRX_Head == tempRX_Tail)
 782               	.LM37:
 783 00d0 9217      		cp r25,r18
 784 00d2 01F0      		breq .L16
 161:Src/driver/usart_driver.c **** 	{
 162:Src/driver/usart_driver.c **** 		ans = false;
 163:Src/driver/usart_driver.c **** 	}
 164:Src/driver/usart_driver.c **** 	else
 165:Src/driver/usart_driver.c **** 	{
 166:Src/driver/usart_driver.c **** 		ans = true;
 167:Src/driver/usart_driver.c **** 		usart_data->buffer.RX[usart_data->buffer.RX_Head] = data;
 786               	.LM38:
 787 00d4 2C91      		ld r18,X
 788 00d6 E20F      		add r30,r18
 789 00d8 F11D      		adc r31,__zero_reg__
 790 00da 8383      		std Z+3,r24
 168:Src/driver/usart_driver.c **** 		usart_data->buffer.RX_Head = tempRX_Head;
 792               	.LM39:
 793 00dc 9C93      		st X,r25
 166:Src/driver/usart_driver.c **** 		usart_data->buffer.RX[usart_data->buffer.RX_Head] = data;
 795               	.LM40:
 796 00de 81E0      		ldi r24,lo8(1)
 797 00e0 00C0      		rjmp .L15
 798               	.L16:
 162:Src/driver/usart_driver.c **** 	}
 800               	.LM41:
 801 00e2 80E0      		ldi r24,0
 802               	.L15:
 803               	/* epilogue start */
 169:Src/driver/usart_driver.c **** 	}
 170:Src/driver/usart_driver.c **** 	return ans;
 171:Src/driver/usart_driver.c **** }
 805               	.LM42:
 806 00e4 DF91      		pop r29
 807 00e6 CF91      		pop r28
 808 00e8 0895      		ret
 816               	.Lscope7:
 818               		.stabd	78,0,0
 821               	.global	USART_DataRegEmpty
 823               	USART_DataRegEmpty:
 824               		.stabd	46,0,0
 172:Src/driver/usart_driver.c **** 
 173:Src/driver/usart_driver.c **** /*! \brief Data Register Empty Interrupt Service Routine.
 174:Src/driver/usart_driver.c ****  *
 175:Src/driver/usart_driver.c ****  *  Data Register Empty Interrupt Service Routine.
 176:Src/driver/usart_driver.c ****  *  Transmits one byte from TX software buffer. Disables DRE interrupt if buffer
 177:Src/driver/usart_driver.c ****  *  is empty. Argument is pointer to USART (USART_data_t).
 178:Src/driver/usart_driver.c ****  *
 179:Src/driver/usart_driver.c ****  *  \param usart_data      The USART_data_t struct instance.
 180:Src/driver/usart_driver.c ****  */
 181:Src/driver/usart_driver.c **** void USART_DataRegEmpty(USART_data_t *usart_data)
 182:Src/driver/usart_driver.c **** {
 826               	.LM43:
 827               	.LFBB8:
 828 00ea CF93      		push r28
 829 00ec DF93      		push r29
 830               	/* prologue: function */
 831               	/* frame size = 0 */
 832               	/* stack size = 2 */
 833               	.L__stack_usage = 2
 183:Src/driver/usart_driver.c **** 	USART_Buffer_t *bufPtr;
 184:Src/driver/usart_driver.c **** 	bufPtr = &usart_data->buffer;
 185:Src/driver/usart_driver.c **** 
 186:Src/driver/usart_driver.c **** 	/* Check if all data is transmitted. */
 187:Src/driver/usart_driver.c **** 	uint8_t tempTX_Tail = usart_data->buffer.TX_Tail;
 835               	.LM44:
 836 00ee DC01      		movw r26,r24
 837 00f0 AA5F      		subi r26,-6
 838 00f2 BE4F      		sbci r27,-2
 839 00f4 3C91      		ld r19,X
 188:Src/driver/usart_driver.c **** 	if (bufPtr->TX_Head == tempTX_Tail)
 841               	.LM45:
 842 00f6 FC01      		movw r30,r24
 843 00f8 EB5F      		subi r30,-5
 844 00fa FE4F      		sbci r31,-2
 845 00fc 2081      		ld r18,Z
 846 00fe FC01      		movw r30,r24
 847 0100 C081      		ld r28,Z
 848 0102 D181      		ldd r29,Z+1
 849 0104 3213      		cpse r19,r18
 850 0106 00C0      		rjmp .L18
 851               	.LBB2:
 189:Src/driver/usart_driver.c **** 	{
 190:Src/driver/usart_driver.c **** 		/* Disable DRE interrupts. */
 191:Src/driver/usart_driver.c **** 		uint8_t tempCTRLA = usart_data->usart->CTRLA;
 853               	.LM46:
 854 0108 8B81      		ldd r24,Y+3
 192:Src/driver/usart_driver.c **** 		tempCTRLA = (tempCTRLA & ~USART_DREINTLVL_gm) | USART_DREINTLVL_OFF_gc;
 856               	.LM47:
 857 010a 8C7F      		andi r24,lo8(-4)
 193:Src/driver/usart_driver.c **** 		usart_data->usart->CTRLA = tempCTRLA;
 859               	.LM48:
 860 010c 8B83      		std Y+3,r24
 861               	.LBE2:
 862 010e 00C0      		rjmp .L17
 863               	.L18:
 864               	.LBB3:
 194:Src/driver/usart_driver.c **** 	}
 195:Src/driver/usart_driver.c **** 	else
 196:Src/driver/usart_driver.c **** 	{
 197:Src/driver/usart_driver.c **** 		/* Start transmitting. */
 198:Src/driver/usart_driver.c **** 		uint8_t data = bufPtr->TX[usart_data->buffer.TX_Tail];
 866               	.LM49:
 867 0110 2C91      		ld r18,X
 868 0112 820F      		add r24,r18
 869 0114 911D      		adc r25,__zero_reg__
 870 0116 FC01      		movw r30,r24
 871 0118 ED57      		subi r30,125
 872 011a FF4F      		sbci r31,-1
 873 011c 8081      		ld r24,Z
 199:Src/driver/usart_driver.c **** 		usart_data->usart->DATA = data;
 875               	.LM50:
 876 011e 8883      		st Y,r24
 200:Src/driver/usart_driver.c **** 
 201:Src/driver/usart_driver.c **** 		/* Advance buffer tail. */
 202:Src/driver/usart_driver.c **** 		bufPtr->TX_Tail = (bufPtr->TX_Tail + 1) & USART_TX_BUFFER_MASK;
 878               	.LM51:
 879 0120 8C91      		ld r24,X
 880 0122 8F5F      		subi r24,lo8(-(1))
 881 0124 8F77      		andi r24,lo8(127)
 882 0126 8C93      		st X,r24
 883               	.L17:
 884               	/* epilogue start */
 885               	.LBE3:
 203:Src/driver/usart_driver.c **** 	}
 204:Src/driver/usart_driver.c **** }
 887               	.LM52:
 888 0128 DF91      		pop r29
 889 012a CF91      		pop r28
 890 012c 0895      		ret
 898               	.Lscope8:
 900               		.stabd	78,0,0
 904               	.global	USART_NineBits_PutChar
 906               	USART_NineBits_PutChar:
 907               		.stabd	46,0,0
 205:Src/driver/usart_driver.c **** 
 206:Src/driver/usart_driver.c **** /*! \brief Put data (9 bit character).
 207:Src/driver/usart_driver.c ****  *
 208:Src/driver/usart_driver.c ****  *  Use the function USART_IsTXDataRegisterEmpty before using this function to
 209:Src/driver/usart_driver.c ****  *  put 9 bit character to the TX register.
 210:Src/driver/usart_driver.c ****  *
 211:Src/driver/usart_driver.c ****  *  \param usart      The USART module.
 212:Src/driver/usart_driver.c ****  *  \param data       The data to send.
 213:Src/driver/usart_driver.c ****  */
 214:Src/driver/usart_driver.c **** void USART_NineBits_PutChar(USART_t *usart, uint16_t data)
 215:Src/driver/usart_driver.c **** {
 909               	.LM53:
 910               	.LFBB9:
 911               	/* prologue: function */
 912               	/* frame size = 0 */
 913               	/* stack size = 0 */
 914               	.L__stack_usage = 0
 915 012e FC01      		movw r30,r24
 216:Src/driver/usart_driver.c **** 	if (data & 0x0100)
 217:Src/driver/usart_driver.c **** 	{
 218:Src/driver/usart_driver.c **** 		usart->CTRLB |= USART_TXB8_bm;
 917               	.LM54:
 918 0130 8481      		ldd r24,Z+4
 216:Src/driver/usart_driver.c **** 	if (data & 0x0100)
 920               	.LM55:
 921 0132 70FF      		sbrs r23,0
 922 0134 00C0      		rjmp .L21
 924               	.LM56:
 925 0136 8160      		ori r24,lo8(1)
 926 0138 00C0      		rjmp .L23
 927               	.L21:
 219:Src/driver/usart_driver.c **** 	}
 220:Src/driver/usart_driver.c **** 	else
 221:Src/driver/usart_driver.c **** 	{
 222:Src/driver/usart_driver.c **** 		usart->CTRLB &= ~USART_TXB8_bm;
 929               	.LM57:
 930 013a 8E7F      		andi r24,lo8(-2)
 931               	.L23:
 932 013c 8483      		std Z+4,r24
 223:Src/driver/usart_driver.c **** 	}
 224:Src/driver/usart_driver.c **** 
 225:Src/driver/usart_driver.c **** 	usart->DATA = (data & 0x00FF);
 934               	.LM58:
 935 013e 6083      		st Z,r22
 936 0140 0895      		ret
 938               	.Lscope9:
 940               		.stabd	78,0,0
 943               	.global	USART_NineBits_GetChar
 945               	USART_NineBits_GetChar:
 946               		.stabd	46,0,0
 226:Src/driver/usart_driver.c **** }
 227:Src/driver/usart_driver.c **** 
 228:Src/driver/usart_driver.c **** /*! \brief Get received data (9 bit character).
 229:Src/driver/usart_driver.c ****  *
 230:Src/driver/usart_driver.c ****  *  This function reads out the received 9 bit character (uint16_t).
 231:Src/driver/usart_driver.c ****  *  Use the function USART_RXComplete to check if anything is received.
 232:Src/driver/usart_driver.c ****  *
 233:Src/driver/usart_driver.c ****  *  \param usart      The USART module.
 234:Src/driver/usart_driver.c ****  *
 235:Src/driver/usart_driver.c ****  *  \retval           Received data.
 236:Src/driver/usart_driver.c ****  */
 237:Src/driver/usart_driver.c **** uint16_t USART_NineBits_GetChar(USART_t *usart)
 238:Src/driver/usart_driver.c **** {
 948               	.LM59:
 949               	.LFBB10:
 950               	/* prologue: function */
 951               	/* frame size = 0 */
 952               	/* stack size = 0 */
 953               	.L__stack_usage = 0
 954 0142 FC01      		movw r30,r24
 239:Src/driver/usart_driver.c **** 	if (usart->CTRLB & USART_RXB8_bm)
 956               	.LM60:
 957 0144 8481      		ldd r24,Z+4
 958 0146 80FF      		sbrs r24,0
 959 0148 00C0      		rjmp .L25
 240:Src/driver/usart_driver.c **** 	{
 241:Src/driver/usart_driver.c **** 		return (0x0100 | usart->DATA);
 961               	.LM61:
 962 014a 8081      		ld r24,Z
 963 014c 90E0      		ldi r25,0
 964 014e 9160      		ori r25,1
 965 0150 0895      		ret
 966               	.L25:
 242:Src/driver/usart_driver.c **** 	}
 243:Src/driver/usart_driver.c **** 	else
 244:Src/driver/usart_driver.c **** 	{
 245:Src/driver/usart_driver.c **** 		return (usart->DATA);
 968               	.LM62:
 969 0152 8081      		ld r24,Z
 970 0154 90E0      		ldi r25,0
 246:Src/driver/usart_driver.c **** 	}
 247:Src/driver/usart_driver.c **** }
 972               	.LM63:
 973 0156 0895      		ret
 975               	.Lscope10:
 977               		.stabd	78,0,0
 979               	.Letext0:
 980               		.ident	"GCC: (GNU) 5.4.0"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 usart_driver.c
     /tmp/ccEbJGwh.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccEbJGwh.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccEbJGwh.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccEbJGwh.s:5      *ABS*:0000000000000034 __CCP__
     /tmp/ccEbJGwh.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccEbJGwh.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccEbJGwh.s:487    .text:0000000000000000 USART_InterruptDriver_Initialize
     /tmp/ccEbJGwh.s:531    .text:000000000000001c USART_InterruptDriver_DreInterruptLevel_Set
     /tmp/ccEbJGwh.s:553    .text:0000000000000022 USART_TXBuffer_FreeSpace
     /tmp/ccEbJGwh.s:596    .text:000000000000003c USART_TXBuffer_PutByte
     /tmp/ccEbJGwh.s:669    .text:000000000000007e USART_RXBufferData_Available
     /tmp/ccEbJGwh.s:710    .text:0000000000000094 USART_RXBuffer_GetByte
     /tmp/ccEbJGwh.s:750    .text:00000000000000b0 USART_RXComplete
     /tmp/ccEbJGwh.s:823    .text:00000000000000ea USART_DataRegEmpty
     /tmp/ccEbJGwh.s:906    .text:000000000000012e USART_NineBits_PutChar
     /tmp/ccEbJGwh.s:945    .text:0000000000000142 USART_NineBits_GetChar

NO UNDEFINED SYMBOLS
