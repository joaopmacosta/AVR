   1               		.file	"TC_driver.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 478               	.global	TC0_ConfigClockSource
 480               	TC0_ConfigClockSource:
 481               		.stabd	46,0,0
   1:TC_driver/TC_driver.c **** /* This file has been prepared for Doxygen automatic documentation generation.*/   
   2:TC_driver/TC_driver.c **** /*! \file *********************************************************************  
   3:TC_driver/TC_driver.c ****  *  
   4:TC_driver/TC_driver.c ****  * \brief  XMEGA Timer/Counter driver source file.  
   5:TC_driver/TC_driver.c ****  *  
   6:TC_driver/TC_driver.c ****  *      This file contains the function implementations the XMEGA Timer/Counter  
   7:TC_driver/TC_driver.c ****  *      driver.  
   8:TC_driver/TC_driver.c ****  *  
   9:TC_driver/TC_driver.c ****  *      The driver is not intended for size and/or speed critical code, since  
  10:TC_driver/TC_driver.c ****  *      most functions are just a few lines of code, and the function call  
  11:TC_driver/TC_driver.c ****  *      overhead would decrease code performance. The driver is intended for  
  12:TC_driver/TC_driver.c ****  *      rapid prototyping and documentation purposes for getting started with  
  13:TC_driver/TC_driver.c ****  *      the XMEGA Timer/Counter module.  
  14:TC_driver/TC_driver.c ****  *  
  15:TC_driver/TC_driver.c ****  *      For size and/or speed critical code, it is recommended to copy the  
  16:TC_driver/TC_driver.c ****  *      function contents directly into your application instead of making  
  17:TC_driver/TC_driver.c ****  *      a function call.  
  18:TC_driver/TC_driver.c ****  *  
  19:TC_driver/TC_driver.c ****  *      Several functions use the following construct:  
  20:TC_driver/TC_driver.c ****  *          "some_register = ... | (some_parameter ? SOME_BIT_bm : 0) | ..."  
  21:TC_driver/TC_driver.c ****  *      Although the use of the ternary operator ( if ? then : else ) is discouraged,  
  22:TC_driver/TC_driver.c ****  *      in some occasions the operator makes it possible to write pretty clean and  
  23:TC_driver/TC_driver.c ****  *      neat code. In this driver, the construct is used to set or not set a  
  24:TC_driver/TC_driver.c ****  *      configuration bit based on a boolean input parameter, such as  
  25:TC_driver/TC_driver.c ****  *      the "some_parameter" in the example above.  
  26:TC_driver/TC_driver.c ****  *  
  27:TC_driver/TC_driver.c ****  * \par Application note:  
  28:TC_driver/TC_driver.c ****  *      AVR1306: Using the XMEGA Timer/Counter  
  29:TC_driver/TC_driver.c ****  *  
  30:TC_driver/TC_driver.c ****  * \par Documentation  
  31:TC_driver/TC_driver.c ****  *      For comprehensive code documentation, supported compilers, compiler  
  32:TC_driver/TC_driver.c ****  *      settings and supported devices see readme.html  
  33:TC_driver/TC_driver.c ****  *  
  34:TC_driver/TC_driver.c ****  * \author  
  35:TC_driver/TC_driver.c ****  *      Atmel Corporation: http://www.atmel.com \n  
  36:TC_driver/TC_driver.c ****  *      Support email: avr@atmel.com  
  37:TC_driver/TC_driver.c ****  *  
  38:TC_driver/TC_driver.c ****  * $Revision: 1569 $  
  39:TC_driver/TC_driver.c ****  * $Date: 2008-04-22 13:03:43 +0200 (ti, 22 apr 2008) $  \n  
  40:TC_driver/TC_driver.c ****  *  
  41:TC_driver/TC_driver.c ****  * Copyright (c) 2008, Atmel Corporation All rights reserved.  
  42:TC_driver/TC_driver.c ****  *  
  43:TC_driver/TC_driver.c ****  * Redistribution and use in source and binary forms, with or without  
  44:TC_driver/TC_driver.c ****  * modification, are permitted provided that the following conditions are met:  
  45:TC_driver/TC_driver.c ****  *  
  46:TC_driver/TC_driver.c ****  * 1. Redistributions of source code must retain the above copyright notice,  
  47:TC_driver/TC_driver.c ****  * this list of conditions and the following disclaimer.  
  48:TC_driver/TC_driver.c ****  *  
  49:TC_driver/TC_driver.c ****  * 2. Redistributions in binary form must reproduce the above copyright notice,  
  50:TC_driver/TC_driver.c ****  * this list of conditions and the following disclaimer in the documentation  
  51:TC_driver/TC_driver.c ****  * and/or other materials provided with the distribution.  
  52:TC_driver/TC_driver.c ****  *  
  53:TC_driver/TC_driver.c ****  * 3. The name of ATMEL may not be used to endorse or promote products derived  
  54:TC_driver/TC_driver.c ****  * from this software without specific prior written permission.  
  55:TC_driver/TC_driver.c ****  *  
  56:TC_driver/TC_driver.c ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED  
  57:TC_driver/TC_driver.c ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  
  58:TC_driver/TC_driver.c ****  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND  
  59:TC_driver/TC_driver.c ****  * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,  
  60:TC_driver/TC_driver.c ****  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  
  61:TC_driver/TC_driver.c ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  
  62:TC_driver/TC_driver.c ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  
  63:TC_driver/TC_driver.c ****  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  
  64:TC_driver/TC_driver.c ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  
  65:TC_driver/TC_driver.c ****  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  
  66:TC_driver/TC_driver.c ****  *****************************************************************************/   
  67:TC_driver/TC_driver.c ****    
  68:TC_driver/TC_driver.c **** #include "avr_compiler.h"   
  69:TC_driver/TC_driver.c **** #include "TC_driver.h"   
  70:TC_driver/TC_driver.c ****    
  71:TC_driver/TC_driver.c **** /*! \brief Configures clock source for the Timer/Counter 0.  
  72:TC_driver/TC_driver.c ****  *  
  73:TC_driver/TC_driver.c ****  *  This function clears the old clock source setting of the Timer/Counter and  
  74:TC_driver/TC_driver.c ****  *  sets a new clock source according to the clockSelection parameter.  
  75:TC_driver/TC_driver.c ****  *  
  76:TC_driver/TC_driver.c ****  *  \param tc              Timer/Counter module instance.  
  77:TC_driver/TC_driver.c ****  *  \param clockSelection  Timer/Counter clock source setting.  
  78:TC_driver/TC_driver.c ****  */   
  79:TC_driver/TC_driver.c **** void TC0_ConfigClockSource( volatile TC0_t * tc, TC_CLKSEL_t clockSelection )   
  80:TC_driver/TC_driver.c **** {   
 483               	.LM0:
 484               	.LFBB1:
 485               	/* prologue: function */
 486               	/* frame size = 0 */
 487               	/* stack size = 0 */
 488               	.L__stack_usage = 0
 489 0000 FC01      		movw r30,r24
  81:TC_driver/TC_driver.c ****     tc->CTRLA = ( tc->CTRLA & ~TC0_CLKSEL_gm ) | clockSelection;   
 491               	.LM1:
 492 0002 9081      		ld r25,Z
 493 0004 907F      		andi r25,lo8(-16)
 494 0006 692B      		or r22,r25
 495 0008 6083      		st Z,r22
 496 000a 0895      		ret
 498               	.Lscope1:
 500               		.stabd	78,0,0
 504               	.global	TC1_ConfigClockSource
 506               	TC1_ConfigClockSource:
 507               		.stabd	46,0,0
  82:TC_driver/TC_driver.c **** }   
  83:TC_driver/TC_driver.c ****    
  84:TC_driver/TC_driver.c **** /*! \brief Configures clock source for the Timer/Counter 1.  
  85:TC_driver/TC_driver.c ****  *  
  86:TC_driver/TC_driver.c ****  *  This function clears the old clock source setting of the Timer/Counter and  
  87:TC_driver/TC_driver.c ****  *  sets a new clock source according to the clockSelection parameter.  
  88:TC_driver/TC_driver.c ****  *  
  89:TC_driver/TC_driver.c ****  *  \param tc              Timer/Counter module instance.  
  90:TC_driver/TC_driver.c ****  *  \param clockSelection  Timer/Counter clock source setting.  
  91:TC_driver/TC_driver.c ****  */   
  92:TC_driver/TC_driver.c **** void TC1_ConfigClockSource( volatile TC1_t * tc, TC_CLKSEL_t clockSelection )   
  93:TC_driver/TC_driver.c **** {   
 509               	.LM2:
 510               	.LFBB2:
 511               	/* prologue: function */
 512               	/* frame size = 0 */
 513               	/* stack size = 0 */
 514               	.L__stack_usage = 0
 515 000c FC01      		movw r30,r24
  94:TC_driver/TC_driver.c ****     tc->CTRLA = ( tc->CTRLA & ~TC1_CLKSEL_gm ) | clockSelection;   
 517               	.LM3:
 518 000e 9081      		ld r25,Z
 519 0010 907F      		andi r25,lo8(-16)
 520 0012 692B      		or r22,r25
 521 0014 6083      		st Z,r22
 522 0016 0895      		ret
 524               	.Lscope2:
 526               		.stabd	78,0,0
 530               	.global	TC0_ConfigWGM
 532               	TC0_ConfigWGM:
 533               		.stabd	46,0,0
  95:TC_driver/TC_driver.c **** }   
  96:TC_driver/TC_driver.c ****    
  97:TC_driver/TC_driver.c ****    
  98:TC_driver/TC_driver.c **** /*! \brief Configures the Waveform Generation Mode for the Timer/Counter 0.  
  99:TC_driver/TC_driver.c ****  *  
 100:TC_driver/TC_driver.c ****  *  This function clears the old WGM setting of the Timer/Counter and sets a  
 101:TC_driver/TC_driver.c ****  *  new WGM setting according to the wgm parameter.  
 102:TC_driver/TC_driver.c ****  *  
 103:TC_driver/TC_driver.c ****  *  \param tc    Timer/Counter module instance.  
 104:TC_driver/TC_driver.c ****  *  \param wgm   Waveform generation mode.  
 105:TC_driver/TC_driver.c ****  */   
 106:TC_driver/TC_driver.c **** void TC0_ConfigWGM( volatile TC0_t * tc, TC_WGMODE_t wgm )   
 107:TC_driver/TC_driver.c **** {   
 535               	.LM4:
 536               	.LFBB3:
 537               	/* prologue: function */
 538               	/* frame size = 0 */
 539               	/* stack size = 0 */
 540               	.L__stack_usage = 0
 541 0018 FC01      		movw r30,r24
 108:TC_driver/TC_driver.c ****     tc->CTRLB = ( tc->CTRLB & ~TC0_WGMODE_gm ) | wgm;   
 543               	.LM5:
 544 001a 9181      		ldd r25,Z+1
 545 001c 987F      		andi r25,lo8(-8)
 546 001e 692B      		or r22,r25
 547 0020 6183      		std Z+1,r22
 548 0022 0895      		ret
 550               	.Lscope3:
 552               		.stabd	78,0,0
 556               	.global	TC1_ConfigWGM
 558               	TC1_ConfigWGM:
 559               		.stabd	46,0,0
 109:TC_driver/TC_driver.c **** }   
 110:TC_driver/TC_driver.c ****    
 111:TC_driver/TC_driver.c ****    
 112:TC_driver/TC_driver.c **** /*! \brief Configures the Waveform Generation Mode for the Timer/Counter 1.  
 113:TC_driver/TC_driver.c ****  *  
 114:TC_driver/TC_driver.c ****  *  This function clears the old WGM setting of the Timer/Counter and sets a  
 115:TC_driver/TC_driver.c ****  *  new WGM setting according to the wgm parameter.  
 116:TC_driver/TC_driver.c ****  *  
 117:TC_driver/TC_driver.c ****  *  \param tc    Timer/Counter module instance.  
 118:TC_driver/TC_driver.c ****  *  \param wgm   Waveform generation mode.  
 119:TC_driver/TC_driver.c ****  */   
 120:TC_driver/TC_driver.c **** void TC1_ConfigWGM( volatile TC1_t * tc, TC_WGMODE_t wgm )   
 121:TC_driver/TC_driver.c **** {   
 561               	.LM6:
 562               	.LFBB4:
 563               	/* prologue: function */
 564               	/* frame size = 0 */
 565               	/* stack size = 0 */
 566               	.L__stack_usage = 0
 567 0024 FC01      		movw r30,r24
 122:TC_driver/TC_driver.c ****     tc->CTRLB = ( tc->CTRLB & ~TC1_WGMODE_gm ) | wgm;   
 569               	.LM7:
 570 0026 9181      		ldd r25,Z+1
 571 0028 987F      		andi r25,lo8(-8)
 572 002a 692B      		or r22,r25
 573 002c 6183      		std Z+1,r22
 574 002e 0895      		ret
 576               	.Lscope4:
 578               		.stabd	78,0,0
 582               	.global	TC0_ConfigInputCapture
 584               	TC0_ConfigInputCapture:
 585               		.stabd	46,0,0
 123:TC_driver/TC_driver.c **** }   
 124:TC_driver/TC_driver.c ****    
 125:TC_driver/TC_driver.c ****    
 126:TC_driver/TC_driver.c **** /*! \brief Configures the Timer/Counter 0 for input capture operation.  
 127:TC_driver/TC_driver.c ****  *  
 128:TC_driver/TC_driver.c ****  *  This function sets the Timer/Counter in input capture mode and selects  
 129:TC_driver/TC_driver.c ****  *  the event lines that will trigger the individual input capture channels.  
 130:TC_driver/TC_driver.c ****  *  
 131:TC_driver/TC_driver.c ****  *  \note Output compare operation is disabled when input capture operation is  
 132:TC_driver/TC_driver.c ****  *  enabled.  
 133:TC_driver/TC_driver.c ****  *  
 134:TC_driver/TC_driver.c ****  *  \param tc               Timer/Counter module instance.  
 135:TC_driver/TC_driver.c ****  *  \param eventSource      Event source selection.  
 136:TC_driver/TC_driver.c ****  */   
 137:TC_driver/TC_driver.c **** void TC0_ConfigInputCapture( volatile TC0_t * tc, TC_EVSEL_t eventSource )   
 138:TC_driver/TC_driver.c **** {   
 587               	.LM8:
 588               	.LFBB5:
 589               	/* prologue: function */
 590               	/* frame size = 0 */
 591               	/* stack size = 0 */
 592               	.L__stack_usage = 0
 593 0030 FC01      		movw r30,r24
 139:TC_driver/TC_driver.c ****     tc->CTRLD = ( tc->CTRLD & ~( TC0_EVSEL_gm | TC0_EVACT_gm ) ) |   
 595               	.LM9:
 596 0032 9381      		ldd r25,Z+3
 597 0034 9071      		andi r25,lo8(16)
 598 0036 9062      		ori r25,lo8(32)
 599 0038 962B      		or r25,r22
 600 003a 9383      		std Z+3,r25
 601 003c 0895      		ret
 603               	.Lscope5:
 605               		.stabd	78,0,0
 609               	.global	TC1_ConfigInputCapture
 611               	TC1_ConfigInputCapture:
 612               		.stabd	46,0,0
 140:TC_driver/TC_driver.c ****                 eventSource |   
 141:TC_driver/TC_driver.c ****                 TC_EVACT_CAPT_gc;   
 142:TC_driver/TC_driver.c **** }   
 143:TC_driver/TC_driver.c ****    
 144:TC_driver/TC_driver.c ****    
 145:TC_driver/TC_driver.c **** /*! \brief Configures the Timer/Counter 1 for input capture operation.  
 146:TC_driver/TC_driver.c ****  *  
 147:TC_driver/TC_driver.c ****  *  This function sets the Timer/Counter in input capture mode and selects  
 148:TC_driver/TC_driver.c ****  *  the event lines that will trigger the individual input capture channels.  
 149:TC_driver/TC_driver.c ****  *  
 150:TC_driver/TC_driver.c ****  *  \note Output compare operation is disabled when input capture operation is  
 151:TC_driver/TC_driver.c ****  *  enabled.  
 152:TC_driver/TC_driver.c ****  *  
 153:TC_driver/TC_driver.c ****  *  \param tc               Timer/Counter module instance.  
 154:TC_driver/TC_driver.c ****  *  \param eventSource      Event source selection.  
 155:TC_driver/TC_driver.c ****  */   
 156:TC_driver/TC_driver.c **** void TC1_ConfigInputCapture( volatile TC1_t * tc, TC_EVSEL_t eventSource )   
 157:TC_driver/TC_driver.c **** {   
 614               	.LM10:
 615               	.LFBB6:
 616               	/* prologue: function */
 617               	/* frame size = 0 */
 618               	/* stack size = 0 */
 619               	.L__stack_usage = 0
 620 003e FC01      		movw r30,r24
 158:TC_driver/TC_driver.c ****     tc->CTRLD = ( tc->CTRLD & ~( TC1_EVSEL_gm | TC1_EVACT_gm ) ) |   
 622               	.LM11:
 623 0040 9381      		ldd r25,Z+3
 624 0042 9071      		andi r25,lo8(16)
 625 0044 9062      		ori r25,lo8(32)
 626 0046 962B      		or r25,r22
 627 0048 9383      		std Z+3,r25
 628 004a 0895      		ret
 630               	.Lscope6:
 632               		.stabd	78,0,0
 636               	.global	TC0_EnableCCChannels
 638               	TC0_EnableCCChannels:
 639               		.stabd	46,0,0
 159:TC_driver/TC_driver.c ****                 eventSource |   
 160:TC_driver/TC_driver.c ****                 TC_EVACT_CAPT_gc;   
 161:TC_driver/TC_driver.c **** }   
 162:TC_driver/TC_driver.c ****    
 163:TC_driver/TC_driver.c ****    
 164:TC_driver/TC_driver.c **** /*! \brief Enables compare/capture channels for Timer/Counter 0.  
 165:TC_driver/TC_driver.c ****  *  
 166:TC_driver/TC_driver.c ****  *  This function enables compare/capture channels according to the supplied  
 167:TC_driver/TC_driver.c ****  *  enableMask. The enableMask can be obtained by ORing together the symbols  
 168:TC_driver/TC_driver.c ****  *    - TC0_CCAEN_bm  
 169:TC_driver/TC_driver.c ****  *    - TC0_CCBEN_bm  
 170:TC_driver/TC_driver.c ****  *    - TC0_CCCEN_bm  
 171:TC_driver/TC_driver.c ****  *    - TC0_CCDEN_bm  
 172:TC_driver/TC_driver.c ****  *  
 173:TC_driver/TC_driver.c ****  *  Example: TC0_EnableCCChannels( &TCC0, TC0_CCAEN_bm | TC0_CCCEN_bm ) will  
 174:TC_driver/TC_driver.c ****  *  enable channels A and C.  
 175:TC_driver/TC_driver.c ****  *  
 176:TC_driver/TC_driver.c ****  *  \note No capture/compare channels are disabled by calling this function.  
 177:TC_driver/TC_driver.c ****  *  Disabling is done by calling \ref TC0_DisableCCChannels.  
 178:TC_driver/TC_driver.c ****  *  
 179:TC_driver/TC_driver.c ****  *  \param tc               Timer/Counter module instance.  
 180:TC_driver/TC_driver.c ****  *  \param enableMask       Mask of channels to enable.  
 181:TC_driver/TC_driver.c ****  */   
 182:TC_driver/TC_driver.c **** void TC0_EnableCCChannels( volatile TC0_t * tc, uint8_t enableMask )   
 183:TC_driver/TC_driver.c **** {   
 641               	.LM12:
 642               	.LFBB7:
 643               	/* prologue: function */
 644               	/* frame size = 0 */
 645               	/* stack size = 0 */
 646               	.L__stack_usage = 0
 647 004c FC01      		movw r30,r24
 184:TC_driver/TC_driver.c ****     /* Make sure only CCxEN bits are set in enableMask. */   
 185:TC_driver/TC_driver.c ****     enableMask &= ( TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm );   
 186:TC_driver/TC_driver.c ****    
 187:TC_driver/TC_driver.c ****     /* Enable channels. */   
 188:TC_driver/TC_driver.c ****     tc->CTRLB |= enableMask;   
 649               	.LM13:
 650 004e 9181      		ldd r25,Z+1
 651 0050 607F      		andi r22,lo8(-16)
 652 0052 692B      		or r22,r25
 653 0054 6183      		std Z+1,r22
 654 0056 0895      		ret
 656               	.Lscope7:
 658               		.stabd	78,0,0
 662               	.global	TC1_EnableCCChannels
 664               	TC1_EnableCCChannels:
 665               		.stabd	46,0,0
 189:TC_driver/TC_driver.c **** }   
 190:TC_driver/TC_driver.c ****    
 191:TC_driver/TC_driver.c **** /*! \brief Enables compare/capture channels for Timer/Counter 1.  
 192:TC_driver/TC_driver.c ****  *  
 193:TC_driver/TC_driver.c ****  *  This function enables compare/capture channels according to the supplied  
 194:TC_driver/TC_driver.c ****  *  enableMask. The enableMask can be obtained by ORing together the symbols  
 195:TC_driver/TC_driver.c ****  *    - TC1_CCAEN_bm  
 196:TC_driver/TC_driver.c ****  *    - TC1_CCBEN_bm  
 197:TC_driver/TC_driver.c ****  *  
 198:TC_driver/TC_driver.c ****  *  Example: TC1_EnableCCChannels( &TCC1, TC1_CCAEN_bm | TC1_CCBEN_bm ) will  
 199:TC_driver/TC_driver.c ****  *  enable channels A and B.  
 200:TC_driver/TC_driver.c ****  *  
 201:TC_driver/TC_driver.c ****  *  \note No capture/compare channels are disabled by calling this function.  
 202:TC_driver/TC_driver.c ****  *  Disabling is done by calling \ref TC1_DisableCCChannels.  
 203:TC_driver/TC_driver.c ****  *  
 204:TC_driver/TC_driver.c ****  *  \param tc               Timer/Counter module instance.  
 205:TC_driver/TC_driver.c ****  *  \param enableMask       Mask of channels to enable.  
 206:TC_driver/TC_driver.c ****  */   
 207:TC_driver/TC_driver.c **** void TC1_EnableCCChannels( volatile TC1_t * tc, uint8_t enableMask )   
 208:TC_driver/TC_driver.c **** {   
 667               	.LM14:
 668               	.LFBB8:
 669               	/* prologue: function */
 670               	/* frame size = 0 */
 671               	/* stack size = 0 */
 672               	.L__stack_usage = 0
 673 0058 FC01      		movw r30,r24
 209:TC_driver/TC_driver.c ****     /* Make sure only CCxEN bits are set in enableMask. */   
 210:TC_driver/TC_driver.c ****     enableMask &= ( TC1_CCAEN_bm | TC1_CCBEN_bm );   
 211:TC_driver/TC_driver.c ****    
 212:TC_driver/TC_driver.c ****     /* Enable channels. */   
 213:TC_driver/TC_driver.c ****     tc->CTRLB |= enableMask;   
 675               	.LM15:
 676 005a 9181      		ldd r25,Z+1
 677 005c 6073      		andi r22,lo8(48)
 678 005e 692B      		or r22,r25
 679 0060 6183      		std Z+1,r22
 680 0062 0895      		ret
 682               	.Lscope8:
 684               		.stabd	78,0,0
 688               	.global	TC0_DisableCCChannels
 690               	TC0_DisableCCChannels:
 691               		.stabd	46,0,0
 214:TC_driver/TC_driver.c **** }   
 215:TC_driver/TC_driver.c ****    
 216:TC_driver/TC_driver.c ****    
 217:TC_driver/TC_driver.c **** /*! \brief Disables compare/capture channels on Timer/Counter 0.  
 218:TC_driver/TC_driver.c ****  *  
 219:TC_driver/TC_driver.c ****  *  This function disables compare/capture channels according to the supplied  
 220:TC_driver/TC_driver.c ****  *  disableMask. The disableMask can be obtained by ORing together the symbols  
 221:TC_driver/TC_driver.c ****  *    - TC0_CCAEN_bm  
 222:TC_driver/TC_driver.c ****  *    - TC0_CCBEN_bm  
 223:TC_driver/TC_driver.c ****  *    - TC0_CCCEN_bm  
 224:TC_driver/TC_driver.c ****  *    - TC0_CCDEN_bm  
 225:TC_driver/TC_driver.c ****  *  
 226:TC_driver/TC_driver.c ****  *  Example: TC0_DisableCCChannels( &TCC0, TC0_CCAEN_bm | TC0_CCCEN_bm ) will  
 227:TC_driver/TC_driver.c ****  *  disable channels A and C.  
 228:TC_driver/TC_driver.c ****  *  
 229:TC_driver/TC_driver.c ****  *  \param tc               Timer/Counter module instance.  
 230:TC_driver/TC_driver.c ****  *  \param disableMask      Mask of channels to disable.  
 231:TC_driver/TC_driver.c ****  */   
 232:TC_driver/TC_driver.c **** void TC0_DisableCCChannels( volatile TC0_t * tc, uint8_t disableMask )   
 233:TC_driver/TC_driver.c **** {   
 693               	.LM16:
 694               	.LFBB9:
 695               	/* prologue: function */
 696               	/* frame size = 0 */
 697               	/* stack size = 0 */
 698               	.L__stack_usage = 0
 699 0064 FC01      		movw r30,r24
 234:TC_driver/TC_driver.c ****     /* Make sure only CCxEN bits are set in disableMask. */   
 235:TC_driver/TC_driver.c ****     disableMask &= ( TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm );   
 236:TC_driver/TC_driver.c ****    
 237:TC_driver/TC_driver.c ****     /* Disable channels. */   
 238:TC_driver/TC_driver.c ****     tc->CTRLB &= ~disableMask;   
 701               	.LM17:
 702 0066 9181      		ldd r25,Z+1
 703 0068 607F      		andi r22,lo8(-16)
 704 006a 6095      		com r22
 705 006c 6923      		and r22,r25
 706 006e 6183      		std Z+1,r22
 707 0070 0895      		ret
 709               	.Lscope9:
 711               		.stabd	78,0,0
 715               	.global	TC1_DisableCCChannels
 717               	TC1_DisableCCChannels:
 718               		.stabd	46,0,0
 239:TC_driver/TC_driver.c **** }   
 240:TC_driver/TC_driver.c ****    
 241:TC_driver/TC_driver.c ****    
 242:TC_driver/TC_driver.c **** /*! \brief Disables compare/capture channels on Timer/Counter 1.  
 243:TC_driver/TC_driver.c ****  *  
 244:TC_driver/TC_driver.c ****  *  This function disables compare/capture channels according to the supplied  
 245:TC_driver/TC_driver.c ****  *  disableMask. The disableMask can be obtained by ORing together the symbols  
 246:TC_driver/TC_driver.c ****  *    - TC1_CCAEN_bm  
 247:TC_driver/TC_driver.c ****  *    - TC1_CCBEN_bm  
 248:TC_driver/TC_driver.c ****  *  
 249:TC_driver/TC_driver.c ****  *  Example: TC1_DisableCCChannels( &TCC1, TC1_CCAEN_bm | TC1_CCBEN_bm ) will  
 250:TC_driver/TC_driver.c ****  *  disable channels A and B.  
 251:TC_driver/TC_driver.c ****  *  
 252:TC_driver/TC_driver.c ****  *  \param tc               Timer/Counter module instance.  
 253:TC_driver/TC_driver.c ****  *  \param disableMask      Mask of channels to disable.  
 254:TC_driver/TC_driver.c ****  */   
 255:TC_driver/TC_driver.c **** void TC1_DisableCCChannels( volatile TC1_t * tc, uint8_t disableMask )   
 256:TC_driver/TC_driver.c **** {   
 720               	.LM18:
 721               	.LFBB10:
 722               	/* prologue: function */
 723               	/* frame size = 0 */
 724               	/* stack size = 0 */
 725               	.L__stack_usage = 0
 726 0072 FC01      		movw r30,r24
 257:TC_driver/TC_driver.c ****     /* Make sure only CCxEN bits are set in disableMask. */   
 258:TC_driver/TC_driver.c ****     disableMask &= ( TC1_CCAEN_bm | TC1_CCBEN_bm );   
 259:TC_driver/TC_driver.c ****    
 260:TC_driver/TC_driver.c ****     /* Disable channels. */   
 261:TC_driver/TC_driver.c ****     tc->CTRLB &= ~disableMask;   
 728               	.LM19:
 729 0074 9181      		ldd r25,Z+1
 730 0076 6073      		andi r22,lo8(48)
 731 0078 6095      		com r22
 732 007a 6923      		and r22,r25
 733 007c 6183      		std Z+1,r22
 734 007e 0895      		ret
 736               	.Lscope10:
 738               		.stabd	78,0,0
 742               	.global	TC0_SetOverflowIntLevel
 744               	TC0_SetOverflowIntLevel:
 745               		.stabd	46,0,0
 262:TC_driver/TC_driver.c **** }   
 263:TC_driver/TC_driver.c ****    
 264:TC_driver/TC_driver.c **** /*! \brief Sets the overflow interrupt level.  
 265:TC_driver/TC_driver.c ****  *  
 266:TC_driver/TC_driver.c ****  *  This function sets the overflow interrupt level of this Timer/Counter 0.  
 267:TC_driver/TC_driver.c ****  *  
 268:TC_driver/TC_driver.c ****  *  \param tc               Timer/Counter module instance.  
 269:TC_driver/TC_driver.c ****  *  \param intLevel         New overflow interrupt level.  
 270:TC_driver/TC_driver.c ****  */   
 271:TC_driver/TC_driver.c **** void TC0_SetOverflowIntLevel( volatile TC0_t * tc, TC_OVFINTLVL_t intLevel )   
 272:TC_driver/TC_driver.c **** {   
 747               	.LM20:
 748               	.LFBB11:
 749               	/* prologue: function */
 750               	/* frame size = 0 */
 751               	/* stack size = 0 */
 752               	.L__stack_usage = 0
 753 0080 FC01      		movw r30,r24
 273:TC_driver/TC_driver.c ****     tc->INTCTRLA = ( tc->INTCTRLA & ~TC0_OVFINTLVL_gm ) | intLevel;   
 755               	.LM21:
 756 0082 9681      		ldd r25,Z+6
 757 0084 9C7F      		andi r25,lo8(-4)
 758 0086 692B      		or r22,r25
 759 0088 6683      		std Z+6,r22
 760 008a 0895      		ret
 762               	.Lscope11:
 764               		.stabd	78,0,0
 768               	.global	TC1_SetOverflowIntLevel
 770               	TC1_SetOverflowIntLevel:
 771               		.stabd	46,0,0
 274:TC_driver/TC_driver.c **** }   
 275:TC_driver/TC_driver.c ****    
 276:TC_driver/TC_driver.c ****    
 277:TC_driver/TC_driver.c **** /*! \brief Sets the overflow interrupt level.  
 278:TC_driver/TC_driver.c ****  *  
 279:TC_driver/TC_driver.c ****  *  This function sets the overflow interrupt level of this Timer/Counter 1.  
 280:TC_driver/TC_driver.c ****  *  
 281:TC_driver/TC_driver.c ****  *  \param tc               Timer/Counter module instance.  
 282:TC_driver/TC_driver.c ****  *  \param intLevel         New overflow interrupt level.  
 283:TC_driver/TC_driver.c ****  */   
 284:TC_driver/TC_driver.c **** void TC1_SetOverflowIntLevel( volatile TC1_t * tc, TC_OVFINTLVL_t intLevel )   
 285:TC_driver/TC_driver.c **** {   
 773               	.LM22:
 774               	.LFBB12:
 775               	/* prologue: function */
 776               	/* frame size = 0 */
 777               	/* stack size = 0 */
 778               	.L__stack_usage = 0
 779 008c FC01      		movw r30,r24
 286:TC_driver/TC_driver.c ****     tc->INTCTRLA = ( tc->INTCTRLA & ~TC1_OVFINTLVL_gm ) | intLevel;   
 781               	.LM23:
 782 008e 9681      		ldd r25,Z+6
 783 0090 9C7F      		andi r25,lo8(-4)
 784 0092 692B      		or r22,r25
 785 0094 6683      		std Z+6,r22
 786 0096 0895      		ret
 788               	.Lscope12:
 790               		.stabd	78,0,0
 794               	.global	TC0_SetErrorIntLevel
 796               	TC0_SetErrorIntLevel:
 797               		.stabd	46,0,0
 287:TC_driver/TC_driver.c **** }   
 288:TC_driver/TC_driver.c ****    
 289:TC_driver/TC_driver.c ****    
 290:TC_driver/TC_driver.c **** /*! \brief Sets the Error interrupt level.  
 291:TC_driver/TC_driver.c ****  *  
 292:TC_driver/TC_driver.c ****  *  This function sets the overflow interrupt level of this Timer/Counter 0.  
 293:TC_driver/TC_driver.c ****  *  
 294:TC_driver/TC_driver.c ****  *  \param tc               Timer/Counter module instance.  
 295:TC_driver/TC_driver.c ****  *  \param intLevel         New error interrupt level.  
 296:TC_driver/TC_driver.c ****  */   
 297:TC_driver/TC_driver.c **** void TC0_SetErrorIntLevel( volatile TC0_t * tc, TC_ERRINTLVL_t intLevel )   
 298:TC_driver/TC_driver.c **** {   
 799               	.LM24:
 800               	.LFBB13:
 801               	/* prologue: function */
 802               	/* frame size = 0 */
 803               	/* stack size = 0 */
 804               	.L__stack_usage = 0
 805 0098 FC01      		movw r30,r24
 299:TC_driver/TC_driver.c ****     tc->INTCTRLA = ( tc->INTCTRLA & ~TC0_ERRINTLVL_gm ) | intLevel;   
 807               	.LM25:
 808 009a 9681      		ldd r25,Z+6
 809 009c 937F      		andi r25,lo8(-13)
 810 009e 692B      		or r22,r25
 811 00a0 6683      		std Z+6,r22
 812 00a2 0895      		ret
 814               	.Lscope13:
 816               		.stabd	78,0,0
 820               	.global	TC1_SetErrorIntLevel
 822               	TC1_SetErrorIntLevel:
 823               		.stabd	46,0,0
 300:TC_driver/TC_driver.c **** }   
 301:TC_driver/TC_driver.c ****    
 302:TC_driver/TC_driver.c ****    
 303:TC_driver/TC_driver.c **** /*! \brief Sets the Error interrupt level.  
 304:TC_driver/TC_driver.c ****  *  
 305:TC_driver/TC_driver.c ****  *  This function sets the overflow interrupt level of this Timer/Counter 1.  
 306:TC_driver/TC_driver.c ****  *  
 307:TC_driver/TC_driver.c ****  *  \param tc               Timer/Counter module instance.  
 308:TC_driver/TC_driver.c ****  *  \param intLevel         New error interrupt level.  
 309:TC_driver/TC_driver.c ****  */   
 310:TC_driver/TC_driver.c **** void TC1_SetErrorIntLevel( volatile TC1_t * tc, TC_ERRINTLVL_t intLevel )   
 311:TC_driver/TC_driver.c **** {   
 825               	.LM26:
 826               	.LFBB14:
 827               	/* prologue: function */
 828               	/* frame size = 0 */
 829               	/* stack size = 0 */
 830               	.L__stack_usage = 0
 831 00a4 FC01      		movw r30,r24
 312:TC_driver/TC_driver.c ****     tc->INTCTRLA = ( tc->INTCTRLA & ~TC1_ERRINTLVL_gm ) | intLevel;   
 833               	.LM27:
 834 00a6 9681      		ldd r25,Z+6
 835 00a8 937F      		andi r25,lo8(-13)
 836 00aa 692B      		or r22,r25
 837 00ac 6683      		std Z+6,r22
 838 00ae 0895      		ret
 840               	.Lscope14:
 842               		.stabd	78,0,0
 846               	.global	TC0_SetCCAIntLevel
 848               	TC0_SetCCAIntLevel:
 849               		.stabd	46,0,0
 313:TC_driver/TC_driver.c **** }   
 314:TC_driver/TC_driver.c ****    
 315:TC_driver/TC_driver.c ****    
 316:TC_driver/TC_driver.c **** /*! \brief Sets the interrupt level for compare/capture channel A interrupt.  
 317:TC_driver/TC_driver.c ****  *  
 318:TC_driver/TC_driver.c ****  *  This function sets the interrupt level for compare/capture channel A  
 319:TC_driver/TC_driver.c ****  *  interrupt in Timer/Counter 0.  
 320:TC_driver/TC_driver.c ****  *  
 321:TC_driver/TC_driver.c ****  *  \param tc               Timer/Counter module instance.  
 322:TC_driver/TC_driver.c ****  *  \param intLevel         New compare/capture channel A interrupt level.  
 323:TC_driver/TC_driver.c ****  */   
 324:TC_driver/TC_driver.c **** void TC0_SetCCAIntLevel( volatile TC0_t * tc, TC_CCAINTLVL_t intLevel )   
 325:TC_driver/TC_driver.c **** {   
 851               	.LM28:
 852               	.LFBB15:
 853               	/* prologue: function */
 854               	/* frame size = 0 */
 855               	/* stack size = 0 */
 856               	.L__stack_usage = 0
 857 00b0 FC01      		movw r30,r24
 326:TC_driver/TC_driver.c ****     tc->INTCTRLB = ( tc->INTCTRLB & ~TC0_CCAINTLVL_gm ) | intLevel;   
 859               	.LM29:
 860 00b2 9781      		ldd r25,Z+7
 861 00b4 9C7F      		andi r25,lo8(-4)
 862 00b6 692B      		or r22,r25
 863 00b8 6783      		std Z+7,r22
 864 00ba 0895      		ret
 866               	.Lscope15:
 868               		.stabd	78,0,0
 872               	.global	TC1_SetCCAIntLevel
 874               	TC1_SetCCAIntLevel:
 875               		.stabd	46,0,0
 327:TC_driver/TC_driver.c **** }   
 328:TC_driver/TC_driver.c ****    
 329:TC_driver/TC_driver.c ****    
 330:TC_driver/TC_driver.c **** /*! \brief Sets the interrupt level for compare/capture channel A interrupt.  
 331:TC_driver/TC_driver.c ****  *  
 332:TC_driver/TC_driver.c ****  *  This function sets the interrupt level for compare/capture channel A  
 333:TC_driver/TC_driver.c ****  *  interrupt in Timer/Counter 1.  
 334:TC_driver/TC_driver.c ****  *  
 335:TC_driver/TC_driver.c ****  *  \param tc               Timer/Counter module instance.  
 336:TC_driver/TC_driver.c ****  *  \param intLevel         New compare/capture channel A interrupt level.  
 337:TC_driver/TC_driver.c ****  */   
 338:TC_driver/TC_driver.c **** void TC1_SetCCAIntLevel( volatile TC1_t * tc, TC_CCAINTLVL_t intLevel )   
 339:TC_driver/TC_driver.c **** {   
 877               	.LM30:
 878               	.LFBB16:
 879               	/* prologue: function */
 880               	/* frame size = 0 */
 881               	/* stack size = 0 */
 882               	.L__stack_usage = 0
 883 00bc FC01      		movw r30,r24
 340:TC_driver/TC_driver.c ****     tc->INTCTRLB = ( tc->INTCTRLB & ~TC1_CCAINTLVL_gm ) | intLevel;   
 885               	.LM31:
 886 00be 9781      		ldd r25,Z+7
 887 00c0 9C7F      		andi r25,lo8(-4)
 888 00c2 692B      		or r22,r25
 889 00c4 6783      		std Z+7,r22
 890 00c6 0895      		ret
 892               	.Lscope16:
 894               		.stabd	78,0,0
 898               	.global	TC0_SetCCBIntLevel
 900               	TC0_SetCCBIntLevel:
 901               		.stabd	46,0,0
 341:TC_driver/TC_driver.c **** }   
 342:TC_driver/TC_driver.c ****    
 343:TC_driver/TC_driver.c ****    
 344:TC_driver/TC_driver.c **** /*! \brief Sets the interrupt level for compare/capture channel B interrupt.  
 345:TC_driver/TC_driver.c ****  *  
 346:TC_driver/TC_driver.c ****  *  This function sets the interrupt level for compare/capture channel B  
 347:TC_driver/TC_driver.c ****  *  interrupt in Timer/Counter 0.  
 348:TC_driver/TC_driver.c ****  *  
 349:TC_driver/TC_driver.c ****  *  \param tc               Timer/Counter module instance.  
 350:TC_driver/TC_driver.c ****  *  \param intLevel         New compare/capture channel B interrupt level.  
 351:TC_driver/TC_driver.c ****  */   
 352:TC_driver/TC_driver.c **** void TC0_SetCCBIntLevel( volatile TC0_t * tc, TC_CCBINTLVL_t intLevel )   
 353:TC_driver/TC_driver.c **** {   
 903               	.LM32:
 904               	.LFBB17:
 905               	/* prologue: function */
 906               	/* frame size = 0 */
 907               	/* stack size = 0 */
 908               	.L__stack_usage = 0
 909 00c8 FC01      		movw r30,r24
 354:TC_driver/TC_driver.c ****     tc->INTCTRLB = ( tc->INTCTRLB & ~TC0_CCBINTLVL_gm ) | intLevel;   
 911               	.LM33:
 912 00ca 9781      		ldd r25,Z+7
 913 00cc 937F      		andi r25,lo8(-13)
 914 00ce 692B      		or r22,r25
 915 00d0 6783      		std Z+7,r22
 916 00d2 0895      		ret
 918               	.Lscope17:
 920               		.stabd	78,0,0
 924               	.global	TC1_SetCCBIntLevel
 926               	TC1_SetCCBIntLevel:
 927               		.stabd	46,0,0
 355:TC_driver/TC_driver.c **** }   
 356:TC_driver/TC_driver.c ****    
 357:TC_driver/TC_driver.c ****    
 358:TC_driver/TC_driver.c **** /*! \brief Sets the interrupt level for compare/capture channel B interrupt.  
 359:TC_driver/TC_driver.c ****  *  
 360:TC_driver/TC_driver.c ****  *  This function sets the interrupt level for compare/capture channel B  
 361:TC_driver/TC_driver.c ****  *  interrupt in Timer/Counter 1.  
 362:TC_driver/TC_driver.c ****  *  
 363:TC_driver/TC_driver.c ****  *  \param tc               Timer/Counter module instance.  
 364:TC_driver/TC_driver.c ****  *  \param intLevel         New compare/capture channel B interrupt level.  
 365:TC_driver/TC_driver.c ****  */   
 366:TC_driver/TC_driver.c **** void TC1_SetCCBIntLevel( volatile TC1_t * tc, TC_CCBINTLVL_t intLevel )   
 367:TC_driver/TC_driver.c **** {   
 929               	.LM34:
 930               	.LFBB18:
 931               	/* prologue: function */
 932               	/* frame size = 0 */
 933               	/* stack size = 0 */
 934               	.L__stack_usage = 0
 935 00d4 FC01      		movw r30,r24
 368:TC_driver/TC_driver.c ****     tc->INTCTRLB = ( tc->INTCTRLB & ~TC1_CCBINTLVL_gm ) | intLevel;   
 937               	.LM35:
 938 00d6 9781      		ldd r25,Z+7
 939 00d8 937F      		andi r25,lo8(-13)
 940 00da 692B      		or r22,r25
 941 00dc 6783      		std Z+7,r22
 942 00de 0895      		ret
 944               	.Lscope18:
 946               		.stabd	78,0,0
 950               	.global	TC0_SetCCCIntLevel
 952               	TC0_SetCCCIntLevel:
 953               		.stabd	46,0,0
 369:TC_driver/TC_driver.c **** }   
 370:TC_driver/TC_driver.c ****    
 371:TC_driver/TC_driver.c ****    
 372:TC_driver/TC_driver.c **** /*! \brief Sets the interrupt level for compare/capture channel C interrupt.  
 373:TC_driver/TC_driver.c ****  *  
 374:TC_driver/TC_driver.c ****  *  This function sets the interrupt level for compare/capture channel C  
 375:TC_driver/TC_driver.c ****  *  interrupt in Timer/Counter 0.  
 376:TC_driver/TC_driver.c ****  *  
 377:TC_driver/TC_driver.c ****  *  \param tc               Timer/Counter module instance.  
 378:TC_driver/TC_driver.c ****  *  \param intLevel         New compare/capture channel A interrupt level.  
 379:TC_driver/TC_driver.c ****  */   
 380:TC_driver/TC_driver.c **** void TC0_SetCCCIntLevel( volatile TC0_t * tc, TC_CCCINTLVL_t intLevel )   
 381:TC_driver/TC_driver.c **** {   
 955               	.LM36:
 956               	.LFBB19:
 957               	/* prologue: function */
 958               	/* frame size = 0 */
 959               	/* stack size = 0 */
 960               	.L__stack_usage = 0
 961 00e0 FC01      		movw r30,r24
 382:TC_driver/TC_driver.c ****     tc->INTCTRLB = ( tc->INTCTRLB & ~TC0_CCCINTLVL_gm ) | intLevel;   
 963               	.LM37:
 964 00e2 9781      		ldd r25,Z+7
 965 00e4 9F7C      		andi r25,lo8(-49)
 966 00e6 692B      		or r22,r25
 967 00e8 6783      		std Z+7,r22
 968 00ea 0895      		ret
 970               	.Lscope19:
 972               		.stabd	78,0,0
 976               	.global	TC0_SetCCDIntLevel
 978               	TC0_SetCCDIntLevel:
 979               		.stabd	46,0,0
 383:TC_driver/TC_driver.c **** }   
 384:TC_driver/TC_driver.c ****    
 385:TC_driver/TC_driver.c ****    
 386:TC_driver/TC_driver.c **** /*! \brief Sets the interrupt level for compare/capture channel D interrupt.  
 387:TC_driver/TC_driver.c ****  *  
 388:TC_driver/TC_driver.c ****  *  This function sets the interrupt level for compare/capture channel D  
 389:TC_driver/TC_driver.c ****  *  interrupt in Timer/Counter 0.  
 390:TC_driver/TC_driver.c ****  *  
 391:TC_driver/TC_driver.c ****  *  \param tc               Timer/Counter module instance.  
 392:TC_driver/TC_driver.c ****  *  \param intLevel         New compare/capture channel A interrupt level.  
 393:TC_driver/TC_driver.c ****  */   
 394:TC_driver/TC_driver.c **** void TC0_SetCCDIntLevel( volatile TC0_t * tc, TC_CCDINTLVL_t intLevel )   
 395:TC_driver/TC_driver.c **** {   
 981               	.LM38:
 982               	.LFBB20:
 983               	/* prologue: function */
 984               	/* frame size = 0 */
 985               	/* stack size = 0 */
 986               	.L__stack_usage = 0
 987 00ec FC01      		movw r30,r24
 396:TC_driver/TC_driver.c ****     tc->INTCTRLB = ( tc->INTCTRLB & ~TC0_CCDINTLVL_gm ) | intLevel;   
 989               	.LM39:
 990 00ee 9781      		ldd r25,Z+7
 991 00f0 9F73      		andi r25,lo8(63)
 992 00f2 692B      		or r22,r25
 993 00f4 6783      		std Z+7,r22
 994 00f6 0895      		ret
 996               	.Lscope20:
 998               		.stabd	78,0,0
 1001               	.global	TC0_Reset
 1003               	TC0_Reset:
 1004               		.stabd	46,0,0
 397:TC_driver/TC_driver.c **** }   
 398:TC_driver/TC_driver.c ****    
 399:TC_driver/TC_driver.c ****    
 400:TC_driver/TC_driver.c **** /*! \brief Resets the Timer/Counter 0.  
 401:TC_driver/TC_driver.c ****  *  
 402:TC_driver/TC_driver.c ****  *  This function will reset the Timer/Counter. After calling this function,  
 403:TC_driver/TC_driver.c ****  *  the Timer/Counter will be in the same state as it would after a full  
 404:TC_driver/TC_driver.c ****  *  reset of the device.  
 405:TC_driver/TC_driver.c ****  *  
 406:TC_driver/TC_driver.c ****  *  \param tc  Timer/Counter 0 module instance.  
 407:TC_driver/TC_driver.c ****  */   
 408:TC_driver/TC_driver.c **** void TC0_Reset( volatile TC0_t * tc )   
 409:TC_driver/TC_driver.c **** {   
 1006               	.LM40:
 1007               	.LFBB21:
 1008               	/* prologue: function */
 1009               	/* frame size = 0 */
 1010               	/* stack size = 0 */
 1011               	.L__stack_usage = 0
 1012 00f8 FC01      		movw r30,r24
 410:TC_driver/TC_driver.c ****     /* TC must be turned off before a Reset command. */   
 411:TC_driver/TC_driver.c ****     tc->CTRLA = ( tc->CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;   
 1014               	.LM41:
 1015 00fa 8081      		ld r24,Z
 1016 00fc 807F      		andi r24,lo8(-16)
 1017 00fe 8083      		st Z,r24
 412:TC_driver/TC_driver.c ****    
 413:TC_driver/TC_driver.c ****     /* Issue Reset command. */   
 414:TC_driver/TC_driver.c ****     tc->CTRLFSET = TC_CMD_RESET_gc;   
 1019               	.LM42:
 1020 0100 8CE0      		ldi r24,lo8(12)
 1021 0102 8187      		std Z+9,r24
 1022 0104 0895      		ret
 1024               	.Lscope21:
 1026               		.stabd	78,0,0
 1029               	.global	TC1_Reset
 1031               	TC1_Reset:
 1032               		.stabd	46,0,0
 415:TC_driver/TC_driver.c **** }   
 416:TC_driver/TC_driver.c ****    
 417:TC_driver/TC_driver.c ****    
 418:TC_driver/TC_driver.c **** /*! \brief Resets the Timer/Counter 1.  
 419:TC_driver/TC_driver.c ****  *  
 420:TC_driver/TC_driver.c ****  *  This function will reset the Timer/Counter. After calling this function,  
 421:TC_driver/TC_driver.c ****  *  the Timer/Counter will be in the same state as it would after a full  
 422:TC_driver/TC_driver.c ****  *  reset of the device.  
 423:TC_driver/TC_driver.c ****  *  
 424:TC_driver/TC_driver.c ****  *  \param tc  Timer/Counter 1 module instance.  
 425:TC_driver/TC_driver.c ****  */   
 426:TC_driver/TC_driver.c **** void TC1_Reset( volatile TC1_t * tc )   
 427:TC_driver/TC_driver.c **** {   
 1034               	.LM43:
 1035               	.LFBB22:
 1036               	/* prologue: function */
 1037               	/* frame size = 0 */
 1038               	/* stack size = 0 */
 1039               	.L__stack_usage = 0
 1040 0106 FC01      		movw r30,r24
 428:TC_driver/TC_driver.c ****     /* TC must be turned off before a Reset command. */   
 429:TC_driver/TC_driver.c ****     tc->CTRLA = ( tc->CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;   
 1042               	.LM44:
 1043 0108 8081      		ld r24,Z
 1044 010a 807F      		andi r24,lo8(-16)
 1045 010c 8083      		st Z,r24
 430:TC_driver/TC_driver.c ****    
 431:TC_driver/TC_driver.c ****     /* Issue Reset command. */   
 432:TC_driver/TC_driver.c ****     tc->CTRLFSET = TC_CMD_RESET_gc;   
 1047               	.LM45:
 1048 010e 8CE0      		ldi r24,lo8(12)
 1049 0110 8187      		std Z+9,r24
 1050 0112 0895      		ret
 1052               	.Lscope22:
 1054               		.stabd	78,0,0
 1056               	.Letext0:
 1057               		.ident	"GCC: (GNU) 5.4.0"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 TC_driver.c
     /tmp/cc6VQM2j.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc6VQM2j.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc6VQM2j.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc6VQM2j.s:5      *ABS*:0000000000000034 __CCP__
     /tmp/cc6VQM2j.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc6VQM2j.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc6VQM2j.s:480    .text:0000000000000000 TC0_ConfigClockSource
     /tmp/cc6VQM2j.s:506    .text:000000000000000c TC1_ConfigClockSource
     /tmp/cc6VQM2j.s:532    .text:0000000000000018 TC0_ConfigWGM
     /tmp/cc6VQM2j.s:558    .text:0000000000000024 TC1_ConfigWGM
     /tmp/cc6VQM2j.s:584    .text:0000000000000030 TC0_ConfigInputCapture
     /tmp/cc6VQM2j.s:611    .text:000000000000003e TC1_ConfigInputCapture
     /tmp/cc6VQM2j.s:638    .text:000000000000004c TC0_EnableCCChannels
     /tmp/cc6VQM2j.s:664    .text:0000000000000058 TC1_EnableCCChannels
     /tmp/cc6VQM2j.s:690    .text:0000000000000064 TC0_DisableCCChannels
     /tmp/cc6VQM2j.s:717    .text:0000000000000072 TC1_DisableCCChannels
     /tmp/cc6VQM2j.s:744    .text:0000000000000080 TC0_SetOverflowIntLevel
     /tmp/cc6VQM2j.s:770    .text:000000000000008c TC1_SetOverflowIntLevel
     /tmp/cc6VQM2j.s:796    .text:0000000000000098 TC0_SetErrorIntLevel
     /tmp/cc6VQM2j.s:822    .text:00000000000000a4 TC1_SetErrorIntLevel
     /tmp/cc6VQM2j.s:848    .text:00000000000000b0 TC0_SetCCAIntLevel
     /tmp/cc6VQM2j.s:874    .text:00000000000000bc TC1_SetCCAIntLevel
     /tmp/cc6VQM2j.s:900    .text:00000000000000c8 TC0_SetCCBIntLevel
     /tmp/cc6VQM2j.s:926    .text:00000000000000d4 TC1_SetCCBIntLevel
     /tmp/cc6VQM2j.s:952    .text:00000000000000e0 TC0_SetCCCIntLevel
     /tmp/cc6VQM2j.s:978    .text:00000000000000ec TC0_SetCCDIntLevel
     /tmp/cc6VQM2j.s:1003   .text:00000000000000f8 TC0_Reset
     /tmp/cc6VQM2j.s:1031   .text:0000000000000106 TC1_Reset

NO UNDEFINED SYMBOLS
